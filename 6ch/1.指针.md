### 指针

#### 地址

* 整型变量的地址就是它占据四个字节中首个字节的地址 `&a`

#### 指针变量

> 指针变量也是变量

* 不管什么类型的指针占用的空间都是八个字节（64位系统中），存的是变量地址
* 指针变量声明：在相关变量前边加上`*`
* `*`取值、取反
* 任何指针都可已存储任意类型的地址，但是程序中会涉及类型转换
* 指针变量也是有地址的：指向指针变量的指针
* `*p`等价于它所指向的变量`a`
* ***传出参数***  `&a`：
  * `scanf("%d", &a)`

> 值拷贝（函数调用）

* ***等价形式转换***
  * `*p <-> a`
  * `p[0] <-> a`一个整型变量可以看做一个元素的数组
  * `p + 1 <-> &p[1]` 前边是地址，加一后，不同类型地址代表字节数不同
  * 向后移动一个元素，根据指针类型不同，移动字节数不同
* `p -> filed <-> (*p).filed <-> a.filed`
  
* 结构体
  * 间接引用`p -> field`等价于变量名直接引用`a -> field` ， `a + 1`就表示一个地址值不表示结构体了

```c
(*p[1].x) (p[1].x) ((p + 1)->x) (*(p + 1)[x]) (*(a + 1)).x 
```

> 不同类型指针相同，除了：`int`四个字节`char`一个字节。`int*`指针代表的地址减一，那么减四个字节`char*`指针代表的地址减一，那么减一个字节；指针运算时候不同；其他一样

> 结构体中元素的调用：代表地址的用`->`代表值得用`.`

> `*`取的是值，`&`取的是地址

#### 函数指针

> `int *p, q` `*`是用来修饰变量的
>
> 函数指针用来存放函数地址

* `int add(int, int)`
* `int (*add)(int, int)`这里的`add`相当于一个变量。括号防止歧义
* `typedef int (*add)(int, int)`这里`add`变成了类型

#### TYPEDEF用法

> ***typedef 可以把变量变成类型***  ： `typedef long long lint`

* 结构体类型的重命名
  * 

* 函数指针重命名
  * `typedef int (*func)(int)`

#### MAIN函数参数

* `int main()`
* `int main(int argc, char *argv[])` 第二个参数是字符串数组，每一位就是一个命令行参数
* `int main(int argc, char *argv[], char **env)`第三个参数是环境变量，也是字符数组
* `g++ test.cpp` 就是通过命令行参数传入的
* 所有程序都离不开对C语言的理解
* C语言层面解决不了的问题，其他语言都是白扯
* 参考C核心技术，第九章第十章
* LINUX安全，因为和用户强绑定
* 环境变量记录的就是信息，可能是目录，也会是值，不只是记录路径